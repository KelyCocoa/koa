### https://juejin.im/post/5afb0ae56fb9a07aa2138425（学习闭包的前置知识）
- 1、理解作用域是什么？ 作用域就是变量可使用的管理范围。
- 2、词法作用域（静态作用域）和动态作用域。
    - 词法作用域：即变量或函数在定义的时候就确定了其管理范围。
- 3、全局作用域，局部作用域，作用域链，
- 3、作用域中变量的查找规则
    - 输出变量的查找类型是RHS，赋值的查找类型是LHS。L或者R的区别是变量在赋值操作左边则为LHS查询，在右侧则为RHS查询。说白了查询值是RHS，赋值是LHS。


### https://juejin.im/post/5b081f8d6fb9a07a9b3664b6（闭包1）
- 1、返回函数的引用是什么，为什么常规的闭包表示方式能通过函数引用的方式让词法作用域外面的函数访问函数内部的作用域
- 2、为什么通过回调函数的方式，fn2能够访问到fn1函数的变量（知识点：词法作用域在什么时候确定）
- 3、闭包的作用是什么？

### https://juejin.im/post/5b167b476fb9a01e5b10f19b（闭包2）
- 1、什么是抽象？ 抽象就是隐藏更具体的实现细节，从更高的层次看待我们要解决的问题。
- 2、封装一个遍历方法，将for循环的过程隐藏起来，使用遍历方法达到效果
- 3、什么是高阶函数？
    - 就是一个函数可以操作其他函数（实现方式：将其他函数作为参数或将函数作为返回值）

- 4、事件绑定this的指向问题。


### https://segmentfault.com/a/1190000006875662
- 1、变量的生命周期
- 2、闭包在模块化中的一些使用（使用闭包模块，减少全局变量的污染）
- 3、闭包的缺陷（会增加对内存的使用量，影响性能；并且不正确的使用闭包会造成内存泄漏）
- 4、最后一个练习
```
function fun(n,o){
  console.log(o);
  return {
    fun: function(m){
      return fun(m,n);
    }
  };
}

var a = fun(0);  // ?
a.fun(1);        // ?        
a.fun(2);        // ?
a.fun(3);        // ?

var b = fun(0).fun(1).fun(2).fun(3);  // ?

var c = fun(0).fun(1);  // ?
c.fun(2);        // ?
c.fun(3);        // ?
```

### http://hpoenixf.com/%E4%B8%80%E6%AC%A1%E6%90%9E%E5%AE%9A%E9%97%AD%E5%8C%85%E5%92%8Cthis.html
- 执行上下文栈如何产生及内容
    - 5个关键点
        - 单线程
        - 同步执行
        - 一个全局上下文
        - 无限制函数上下文
        - 每次函数调用创建新的上下文，包括调用自己
- 箭头函数自身不存在上下文环境，this指向定义箭头函数环境中this指向的那个对象，即上层作用域中this指向的对象。
- 为什么进行事件监听的时候this指向当前的DOM（未解决）
- 

### https://www.jianshu.com/p/6c6a7403f8fb
- 关于变量和函数声明提升的问题
    - https://www.jianshu.com/p/44a3c76023f5  结论是函数提升 > 变量提升（对的）
    - https://www.cnblogs.com/oxiaojiano/p/7918967.html  结论是函数提升 > 变量提升




