### 两种实现继承的方式

下面有两种实现子类继承父类的原型方法，但是逻辑是不一样的。以前我只是单纯的死记该结论，没有对比两者的区别
```
// 第一种：直接获取实例化的父级实例对象，此时这个实例对象上包含了父类上的所有属性和原型方法。然后直接把这个对象简单粗暴得赋值给子类的原型上，达到了原型继承的目的。
Child.prototype = new Parent();

// 第二种：这个是直接使用原型链的概念直接让子类的原型方法继承自父类的原型方法。
new Child().__proto__ = Parent.prototype;
```


### 把继承的整个过渡过程都总结一遍，包括缺点和优点
- 原型继承
    - 优点：能够继承父类的原型方法
    - 缺点：
        - 不能给超类型的父类传参
        - 超类型的父类属性是引用类型时，该属性会被所有实例共享

- 借用构造函数的继承
    - 优点：解决父类属性是引用类型不被所有实例共享的问题和给子类传参的问题
    - 缺点：
        - 不能继承父类超类型的原型方法

- 组合继承
    - 优点：集合了原型继承和借用构造函数继承的优点
    - 缺点：
        - 父类构造函数会执行两遍。子类的原型对象和原型链中会出现两个相同的同名属性

- 寄生组合式继承
    - 优点：降低调用父类构造函数的开销。
    - 缺点：-


