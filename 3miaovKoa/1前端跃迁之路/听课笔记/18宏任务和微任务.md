微任务可以在实时性和效率之间做一个有效的权衡。基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。

### 宏任务
页面中的大部分宏任务任务都是在主线程上执行的，这些任务包括了：
- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。

宏任务的大致流程是这样的：
- 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
- 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
- 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
- 最后统计执行完成的时长等信息。

但是宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的。比如在将要执行的计时器延迟任务中间插入一个执行时间很久的任务（在主线程上执行）时，如执行10000个数值得循环，那延迟执行的时间就不准确。


### 微任务
上一节课中提到的异步回调的概念，其主要有两种方式：
1、把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。也就是前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的（宏任务）。
2、执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。
微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。


每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点——微任务产生的时机和执行微任务队列的时机。
- 微任务是怎么产生的（在监控某个DOM节点，当DOM节点发生变化时产生DOM变化记录的微任务；或者当调用Promise.resolve() | Promise.reject()时产生了微任务）
（1）使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
（2）使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。
综合上述，即通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。

- 微任务队列是何时被执行（在该宏任务准备结束，即将销毁该执行上下文时，就开始检查微任务队列的任务，并执行）
在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。


### 监听 DOM 变化方法演变
MutationObserver 是用来监听 DOM 变化的一套方法。

刚开始监听DOM变化方案是做轮询检测，即setTimeout或者setInterval定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。

接下来用Mutation Event对轮询检测方法做了改进

Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。

接下来用MutationObserver对Mutation Event方法做了改进

首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。性能问题解决了，那如何保证消息通知的及时性呢？如果使用宏任务setTimeout的话，一旦主线程上的程序出现阻塞，那么延迟时间就不准确了。这个时候就使用微任务。在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。

所以，MutationObserver 采用了“异步 + 微任务”的策略。
- 通过异步操作解决了同步操作的性能问题；
- 通过微任务解决了实时性的问题。


# 提出问题
```
// 下面代码打印什么值


function executor(resolve, reject) {
    let rand = Math.random();
    console.log(1)
    console.log(rand)
    if (rand > 0.5)
        resolve()
    else
        reject()
}
var p0 = new Promise(executor);

var p1 = p0.then((value) => {
    console.log("succeed-1")
    return new Promise(executor)
})


var p3 = p1.then((value) => {
    console.log("succeed-2")
    return new Promise(executor)
})

var p4 = p3.then((value) => {
    console.log("succeed-3")
    return new Promise(executor)
})


p4.catch((error) => {
    console.log("error")
})
console.log(2)
```
// 如果第一次走reject，那么打印1  0.1  2  error
这段代码有四个 Promise 对象：p0～p4。无论哪个对象里面抛出异常，都可以通过最后一个对象 p4.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。


### 疑问1：
1、之前讲过，在循环系统的一个循环中，先从消息队列头部取出一个任务执行，该任务执行完后，再去延迟队列中找到所有的过期任务依次执行完。那前面这句话和本篇文章的这句话好像有矛盾："先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask"

2、”通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。“
在页面生存周期内，全局执行上下文只有一份并且会一直存在调用栈中，只有当页面被关闭的时候全局执行上下文才会消失。页面都快关闭了，把全局执行上下文中的微任务队列中的任务都执行一遍，好像也没啥意义。系统应该不会做没有意义的事情，所以应该是我对全局执行上下文的某处理解有问题，但我又自查不到。
```
我先来解答你的第一个问题：
第一段话是WHATWG标准定义的，在WHATWG规范，定义了在主线程的循环系统中，可以有多个消息队列，比如鼠标事件的队列，IO完成消息队列，渲染任务队列，并且可以给这些消息队列排优先级。

但是在浏览器实现的过程中，目前只有一个消息队列，和一个延迟执行队列。
一个是规范，一个是实现，主要我没有在文中强调这点，所以你会产生的这样的疑问。

关于第二个问题解释起来就比较复杂了，涉及到来了V8是怎么执行的了，专栏中的"全局执行上下文"我没有深入分析。所以我偷懒了，把两个稍微有点不同的概念都称为了“全局执行上下文”，要解释清楚这个问题还要牵涉到V8的一个底层逻辑，既然你提出来了，那我就打算在课程结束后，通过加餐的形式来开一讲，讲清楚了这个还能额外地理解 Realm 概念。
```

### 老师，通过控制面板中修改的样式是不是不会触发MutationObserver？
```
不会，因为没有出发js，这个微任务是v8触发的
```


### 疑问1
第16讲提到了，setTimeout里的延迟任务，是存在一个延迟队列中的。我看精选留言部分老师的回答，提到这个延迟队列实际上是一个hashmap，那么setTimeout的实现还是加到队尾，等到前面的都出队，才执行到这个任务的吗？
```
作者回复: setTimeout因为是定时任务，设定的时间间隔没有到是不会执行，由此需要一个单独的模块来保存定时器的消息，你可以通过该模块取出到期的任务，我们把这个模块叫延时队列，Chrome内部用了个hashmap保存数据，然后又写了取出到期的任务的策略！

通常情况下，是当渲染主线程在执行完一个正常的任务之后，再判断该模块中是否有到期的任务，如果有取出来执行！
```