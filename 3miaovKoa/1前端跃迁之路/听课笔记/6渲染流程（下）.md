上一篇文章讲到渲染的三个过程：构建DOM、样式计算和布局，这一节接着讲渲染未完成的部分。

### 图层树
因为页面中有很多复杂的效果，如一些复杂的 3D 变换、z-index在z轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（这里的图层类似ps的图层）

![图层树](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png)

但并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。


那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？
1、第一点，拥有层叠上下文属性的元素会被提升为单独的一层。页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。如定位属性的元素（position: absolute）、定义透明属性的元素（opacity: 0.6）、使用 CSS 滤镜(filter:blue(5px))的元素等，都拥有层叠上下文属性。

2、第二点，需要剪裁（clip）的地方也会被创建为图层。
裁剪是怎样一种情况？一个div大小限定为200*200px，而div 里面的文字内容比较多超过了父级的容器，这个时候就发生了裁剪。

满足上面两点的其中一个，就会被提升成为单独一层。



### 图层绘制
在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。接下来我们看看渲染引擎是怎么实现图层绘制的？
渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。如：把背景涂成蓝色，在中间画一个矩形，在矩形中间画一个圆.......。所以在图层绘制阶段，输出的内容就是这些待绘制列表。



### 栅格化（raster）操作
绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：

- 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？
首先理解什么是视口？
    通常一个页面可能很大，但是用户只能看到其中的一部分，我们把屏幕可见区域叫做视口。
在页面比较大，视口比较小的情况下，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。
所谓栅格化，是指将图块转换为位图。

【图片保存】

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

【图片保存】
它的整个过程其实是：渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。


### 合成和显示
一旦所有图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。



### 渲染流水线总结、
从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：

【图片】

- 整个流程大概可以总结为如下阶段：
1、渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2、渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3、创建布局树，并计算元素的布局信息。
4、对布局树进行分层，并生成分层树。
5、为每个图层生成绘制列表，并将其提交到合成线程。
6、合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7、合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8、浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。



### 重排（更新了元素的几何属性）

【图片】

通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。


### 重绘（更新元素的绘制属性）

【图片】

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。


### 直接合成阶段
更改一个既不要布局也不要绘制的属性，是怎样一个过程呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。

【图片】

使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。



# 思考
在优化 Web 性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？


### 回答1：
```
减少重绘和重排能提升性能的原因是：
减少重排重绘，相当于少了渲染进程的主线程和非主线程的很多计算和操作，能够加快web的展示。

减少重排重绘, 方法很多：
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化
```


### 渲染进程里的帧的概念是什么样子的呢？一个page是一帧吗
```
可以拿放电影电影来解释，通常，电影的帧速是24，也就是说每秒切换24幅画面，其中的每幅画面就是一帧。

理解什么是帧后，我们在回过头看看我们的页面。由于目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果页面中有一个动画、或一个渐变效果、或者用户正在滚动页面，那么浏览器渲染动画的频率至少要和刷新频率保持一致，也就是每秒需要更新60次，这样我们就能计算出来生成每帧的预算只有（1/60）毫秒，也就是16毫秒多一点(1 秒/ 60 = 16.66 毫秒)。如果超过16毫秒，帧率将下降，并且会出现画面抖动现象，此现象通常被称为卡顿，会对用户体验产生负面影响。

所以，如果想要保证画面的流畅，就需要尽量降低每帧的渲染时间，所以局部更新流水线显得非常重要了，能大大减少处理每帧所消耗的时间。
```


### 浏览器工作流程『从输入 URL 到页面展示』学习笔记
```
用户输入

1. 用户在地址栏按下回车，检查输入（关键字 or 符合 URL 规则），组装完整 URL；
2. 回车前，当前页面执行 onbeforeunload 事件；
3. 浏览器进入加载状态。

URL 请求

1. 浏览器进程通过 IPC 把 URL 请求发送至网络进程；
2. 查找资源缓存（有效期内）；
3. DNS 解析（查询 DNS 缓存）；
4. 进入 TCP 队列（单个域名 TCP 连接数量限制）；
5. 创建 TCP 连接（三次握手）；
6. HTTPS 建立 TLS 连接（client hello, server hello, pre-master key 生成『对话密钥』）；
7. 发送 HTTP 请求（请求行[方法、URL、协议]、请求头 Cookie 等、请求体 POST）；
8. 接受请求（响应行[协议、状态码、状态消息]、响应头、响应体等）；
   - 状态码 301 / 302，根据响应头中的 Location 重定向；
   - 状态码 200，根据响应头中的 Content-Type 决定如何响应（下载文件、加载资源、渲染 HTML）。

准备渲染进程

1. 根据是否同一站点（相同的协议和根域名），决定是否复用渲染进程。

提交文档

1. 浏览器进程接受到网路进程的响应头数据，向渲染进程发送『提交文档』消息；
2. 渲染进程收到『提交文档』消息后，与网络进程建立传输数据『管道』；
3. 传输完成后，渲染进程返回『确认提交』消息给浏览器进程；
4. 浏览器接受『确认提交』消息后，移除旧文档、更新界面、地址栏，导航历史状态等；
5. 此时标识浏览器加载状态的小圆圈，从此前 URL 网络请求时的逆时针选择，即将变成顺时针旋转（进入渲染阶段）。

渲染

渲染流水线

构建 DOM 树

1. 输入：HTML 文档；
2. 处理：HTML 解析器解析；
3. 输出：DOM 数据解构。

样式计算

1. 输入：CSS 文本；
2. 处理：属性值标准化，每个节点具体样式（继承、层叠）；
3. 输出：styleSheets(CSSOM)。

布局(DOM 树中元素的计划位置)

1. DOM & CSSOM 合并成渲染树；
2. 布局树（DOM 树中的可见元素）；
3. 布局计算。


分层

1. 特定节点生成专用图层，生成一棵图层树（层叠上下文、Clip，类似 PhotoShop 里的图层）；
2. 拥有层叠上下文属性（明确定位属性、透明属性、CSS 滤镜、z-index 等）的元素会创建单独图层；
3. 没有图层的 DOM 节点属于父节点图层；
4. 需要剪裁的地方也会创建图层。

绘制指令

1. 输入：图层树；
2. 渲染引擎对图层树中每个图层进行绘制；
3. 拆分成绘制指令，生成绘制列表，提交到合成线程；
4. 输出：绘制列表。

分块

1. 合成线程会将较大、较长的图层（一屏显示不完，大部分不在视口内）划分为图块（tile, 256*256, 512*512）。

光栅化（栅格化）

1. 在光栅化线程池中，将视口附近的图块优先生成位图（栅格化执行该操作）；
2. 快速栅格化：GPU 加速，生成位图（GPU 进程）。

合成绘制

1. 绘制图块命令——DrawQuad，提交给浏览器进程；
2. 浏览器进程的 viz 组件，根据DrawQuad命令，绘制在屏幕上。

相关概念

重排

1. 更新了元素的几何属性（如宽、高、边距）；
2. 触发重新布局，解析之后的一系列子阶段；
3. 更新完成的渲染流水线，开销最大。

重绘

1. 更新元素的绘制属性（元素的颜色、背景色、边框等）；
2. 布局阶段不会执行（无几何位置变换），直接进入绘制阶段。

合成

1. 直接进入合成阶段（例如CSS 的 transform 动画）；
2. 直接执行合成阶段，开销最小。
```



### 问题1：手机端开发，body 被内容撑开了，超过一屏，在滑动的过程中会不会触发重排，为什么？问题2：如果 body 高度设置了100%
```
一般情况下不会触发重绘和重排，只是进行合成操作。

现代浏览器做了优化，把滚动操作交给了合成线程来处理，也就是说滚动的内容会被当成一个单独的图层，发生滚动的事件的时候，图层直接由合成线程来生成，也就是说这种情况下没有占用主线程，所以通常情况下不会产生重排和重回操作，只是简单合成就可以了，这样效率是最高的！

为什么说“通常”呢？ 这是因为目前渲染流程还是很复杂的，在滚动页面时，有些情况下，如果合成线程搞不定的，那么还要交给主线程去处理，这时候就涉及到重拍了，不过技术是往前发展的，渲染流程会变得越来约简单高效！
```

### 回答2
```
重排和重绘都是渲染进程的主线程中进行的，减少这类操作可以减少主线程的资源占用，提高主线程绘制效率。在编写js时尽量减少dom操作或合并dom操作，dom操作需要重新生成dom树，如果影响布局就需要重新生成布局树，再重新生成分层树，再进行绘制。ps：感觉生成个页面好复杂呀，另外，以前从没注意过chrome开发者工具还有个Layers标签，chrome开发者工具真是一堆宝呀。
```


### 渲染流程的最后，应该是浏览器进程将Compositor Frame发送到GPU, GPU进行显示吧？
```
1:首先渲染进程里执行图层合成(Layer Compositor)，也就是生成图层的操作，具体地讲，渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给GPU进程，在GPU进程中执行光栅化操作，执行完成，再将结果返回给渲染进程的合成线程，执行合成图层操作！

2:合成的图层会被提交给浏览器进程，浏览器进程里会执行显示合成(Display Compositor)，也就是将所有的图层合成为可以显示的页面图片。 最终显示器显示的就是浏览器进程中合成的页面图片
```

### 这里的合成线程属于哪个进程？浏览器进程是指主进程吗？
```
合成线程属于渲染进程.

浏览器进程是主进程，负责提供一些基础服务和调度其它进程
```

### 什么叫既不要布局也不要绘制的属性呢?
作者回复: 比如CSS3的实现的一些动画效果


### 总结和整理
```
1，用户输入url并回车，浏览器进程检查url，组装协议，构成完整的url
2，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得
3，浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
4，网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程（状态码200）
5，如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
    5.1 进行DNS解析，获取服务器ip地址：如果缓存过当前域名信息，就会直接返回缓存信息；
    5.2 根据ip地址和服务器建立tcp连接，tcp三次握手。
        5.2.1 传输层生成TCP数据包（包含源端口号、目的端口号），继续向下传输到网络层
        5.2.1 给数据包加上IP头部——包括源IP、目的IP，继续向下传输到物理层
        5.2.1 物理层通过物理网络（如光纤）传输给目的服务器主机
        5.2.1 目的服务器网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层
        5.2.1 目的服务器传输层获取到数据包，解析出TCP头部，识别端口
    5.3 如果是https请求则还需要建立TLS连接。
    5.4 构建请求头信息
    5.5 发送请求头信息
    5.6 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
    5.7 数据传输完成，TCP四次挥手断开连接。如果在HTTP头部加上Connection:Keep-Alive，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度
6，网络进程解析响应流程；
    6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步，
    6.2 如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，
        如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了
    6.3 200响应处理：
        检查响应类型Content-Type。
        如果是 字节流 类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染。
        如果是 text/html 则通知浏览器进程，准备渲染进程进行渲染。
7，准备渲染进程
    7.1 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点）。
        如果相同，则复用原来的进程。
        如果不同，新创建一个新的渲染进程
8. 传输数据、更新状态
    8.1 渲染进程准备好后，浏览器进程向渲染进程发起“提交文档”的消息，渲染进程接收到消息后，和网络进程建立传输数据的“管道”
    8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
    8.3 浏览器进程接收到“确认提交”的消息后，更新浏览器界面状态：包括安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页。

9. 渲染进程渲染页面
    9.1 构建 DOM 树
        9.1.1 输入：HTML 文档 -> 处理：HTML 解析器解析 -> 输出：DOM 数据解构
        9.1.2 具体：接收到Bytes字节流->（转换）HTML字符串->（解析）Token->（构建）Node->（合并）Dom 树
    9.2 样式计算（构建CSSOM树）
        输入：CSS 文本（Link外部引入、style标签、元素style属性）
        处理：通过继承、层叠的方式，让每个节点拥有具体样式
        输出：styleSheets(CSSOM 树)
    9.3 页面布局（构建布局树）
        9.3.1 作用是：计算出 DOM 树中可见元素的几何位置
        9.3.2 具体：先将DOM树和CSSOM树合并为布局树(只包含可见节点)，然后进行布局计算，计算布局树节点的坐标位置。

    9.4 分层
        9.4.1 特定节点生成专用图层，生成一棵图层树（层叠上下文、Clip，类似 PhotoShop 里的图层）；
        9.4.2 拥有层叠上下文属性（明确定位属性、透明属性、CSS 滤镜、z-index 等）的元素会创建单独图层；
        9.4.3 需要剪裁的地方也会创建图层。
        9.4.4 没有图层的 DOM 节点属于父节点图层；


    9.5 图层绘制
        9.5.1 输入：图层树（从9.4来的）；
        9.5.2 渲染引擎对图层树中每个图层进行绘制；
        9.5.3 拆分成绘制指令，生成绘制列表，提交到合成线程；
        9.5.4 输出：绘制列表。

    9.6 分块(将图层划分为图块)
        合成线程会将较大、较长的图层（一屏显示不完，大部分不在视口内）划分为图块（tile, 256*256, 512*512）。

    9.7 栅格化(栅格化，是指将图块转换为位图)
        9.7.1 在栅格化线程池中，将视口附近的图块优先生成位图（栅格化执行该操作）；
        9.7.2 快速栅格化：GPU 加速，生成位图（GPU 进程）。

    9.8 合成和显示
        9.8.1 绘制图块命令——DrawQuad，提交给浏览器进程；
        9.8.2 浏览器进程的 viz 组件，接收合成线程发过来的 DrawQuad 命令，根据DrawQuad命令，绘制在屏幕上。
```


### 渲染进程中，有哪些线程，以及各线程的作用，可以讲解一下吗
```
主要就是个主线程和合成线程，当然还有很多辅助线程，诸如预解析html的线程，预编译javascript线程，垃圾回收线程，合成线程，webworker线程等等。
```


### 我改变了宽高，是不是只对同一图层有影响，其他图层不会重排？
```
目前看是整个页面都需要重排，不过不排除Google以后会优化这块操作
```


### 减少重排重绘可以减少gpu等的调用频次，gpu调用本身开销不小
```
重绘，重排和GPU可没什么关系哦，他们是cpu运算的，且占用浏览器线程！
所以如果没有这两个阶段的操作，那么每秒生成效率会高很多。
```

