要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念，都是你需要重点关注的。

### 编译器和解释器
之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。
按语言的执行流程，可以把语言划分为编译型语言和解释型语言。

- 编译型语言
编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。

- 解释型语言
由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。

那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图：

![](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png)

1、在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
2、在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。

源代码 => AST => 字节码 => 机器码

V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan。接下来分解其执行流程：
1. 生成抽象语法树（AST）和执行上下文
将源代码转换为抽象语法树，并生成执行上下文。

对于编译器和解释器来说，他们只能理解AST。所以这和渲染引擎将HTML格式文件转为计算机可以理解的DOM树情况是类似的。

Babel的工作原理是将ES6源码转为AST，然后再将ES6语法的AST转换为ES5语法的AST，最后利用ES5的AST生成Javascript源代码。

除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。


### 抽象语法树的生成过程：
（1）第一阶段是分词（tokenize），又称为词法分析。
其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。
（2）第二阶段是解析（parse），又称为语法分析。
其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

AST的整个生成过程是：先分词，再解析。而有了AST 后，那接下来 V8 就会生成该段代码的执行上下文。


### 生成字节码的过程：
有了 AST 和执行上下文后，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

之前是V8是直接将 AST 转换为机器码，而执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着Chrome在移动端的广泛普及，V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队重构了引擎架构，引入字节码。

- 什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？
字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。
下面是高级代码、字节码和机器码之间的关系：
！[](https://static001.geekbang.org/resource/image/87/ff/87d1ab147d1dc4b78488e2443d58a3ff.png)
图中可以得出结论：机器码所占用的空间远远超过了字节码


### 执行代码
热点代码：一段代码被重复执行多次。
即时编译（JIT）：实字节码配合解释器和编译器是最近一段时间很火的技术
![](https://static001.geekbang.org/resource/image/66/8a/662413313149f66fe0880113cb6ab98a.png)



### JavaScript 的性能优化
应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：
- 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
- 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
- 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。


### 关键词
- 编译器和解释器
- 源代码，AST抽象树，字节码，机器码
- JavaScript性能优化