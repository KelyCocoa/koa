通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。

- 手动回收策略
如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。

- 自动垃圾回收策略
如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。


因为javascript中数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。

### 调用栈中的数据是如何回收的
看一个栗子：
```
function foo(){
    var a = 1
    var b = {name:"极客邦"}
    function showName(){
      var c = "极客时间"
      var d = {name:"极客时间"}
    }
    showName()
}
foo()
```
当js引擎执行到showName函数时，调用栈中有showName函数的执行上下文和一个记录当前执行状态的指针（简称ESP），这个指针指向栈中showName函数的执行上下文。
当showName函数执行结束之后，showName的执行上下文会被销毁，调用栈中的指针指向上一个函数（foo函数）执行上下文。
这个时候的内存使用情况是这样的：showName的执行上下文已经是无效内存了，新的执行上下文会直接覆盖这块的内存。

所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。



### 堆中的数据是如何回收的

要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。而代际假说是学习垃圾回收机制的基础，我们先来看一下什么是代际假说。

代际假说有以下两个特点：
- 第一个是大部分对象在内存中存在的时间很短。简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

在 V8 中会把堆分为新生代和老生代两个区域。新生代中存放的是生存时间短的对象（通常只支持1-8M容量），老生代中存放的生存时间久的对象（容量就大很多）。而V8分别使用两个不同的垃圾回收器，以便更高效地对这两块存储区域实施垃圾回收。

- 副垃圾回收器，主要负责新生代（1-8M容量）的垃圾回收。
- 主垃圾回收器，主要负责老生代（更多的容量）的垃圾回收。


### 垃圾回收器的工作流程
其实不论上面哪种类型的垃圾回收器，它们都有一套共同的执行流程。流程如下：
1、第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

2、第二步是回收非活动对象占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

3、第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

接下来，按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。


### 副垃圾回收器
副垃圾回收器主要负责新生区的垃圾回收。新生区占用的内存只有1-8M，但是垃圾回收频繁。
并且使用Scavenge 算法来处理垃圾回收
- Scavenge 算法
把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域

![](https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png)

回收过程如下：
1、给对象区域的垃圾做标记
2、将对象区域的垃圾进行清理
3、将清理之后对象区域垃圾之后剩下的活动对象复制到空闲区域，并且将这个对象有序的排列起来。
4、此时对象区域变成了空闲区域，空闲区域变成了对象区域。角色翻转之后继续前面1-3的过程，并且无限循环下去。

为了提高整个新生区执行效率，一般将新生区的空间会被设置得比较小。

因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是在新生区经过两次垃圾回收依然还存活的对象，会被移动到老生区中。



### 主垃圾回收器
主垃圾回收器主要负责老生区中的垃圾回收。老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。
主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

垃圾回收的过程是这样的：
1、首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。（个人理解：这里的递归遍历应该遍历的是整个调用栈的数据，看是否有对堆空间中变量的引用）
比如上面的代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示
![](https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png)

从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。

2、然后是垃圾清除的阶段。
（空，这块没有做介绍）

对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：
![](https://static001.geekbang.org/resource/image/65/8c/652bd2df726d0aa5e67fe8489f39a18c.png)


### 全停顿
V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿

比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：
![](https://static001.geekbang.org/resource/image/98/0c/9898646a08b46bce4f12f918f3c1e60c.png)

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图：
![](https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png)

将完整的标记分成一个个的子标记，并且穿插到js应用逻辑中，那么垃圾回收任务对页面的卡顿影响就变小了。


### 关键点
- js使用的是自动垃圾回收策略
- 栈空间的空间释放是通过移动ESP指针指向不同的执行上下文来实现的。
- 堆空间回收
    - 副垃圾回收器：处理新生代的垃圾回收
        - Scavenge算法：将空间划分成2个区域。一半是对象区域，一半是空闲区域。
    - 主垃圾回收器：处理老生代的垃圾回收
        - 标记 - 清除算法
            - 遍历整个执行栈中的对象，发现堆中的对象还有被栈内的变量所引用，则被标记为活动对象，没有被栈内变量引用的对象标记为垃圾数据。
            - 清除标记的垃圾数据
        - 标记 - 整理算法：由于老生代中储存的数据多且庞大，在清除垃圾之后会存在大量的不连续的内存碎片，这会导致大对象无法分配到足够的连续内存，所以需要在垃圾回收后的活动对象进行整理。


# 思考
你是如何判断 JavaScript 中内存泄漏的？可以结合一些你在工作中避免内存泄漏的方法。


### 对于新生代，副垃圾回收器是怎么进行标记的，文章也就一句话带过了，是和老生代标记算法一样吗？从一组跟元素开始，然后开始遍历的
```
作者回复: 新生区和老生区标记过程是同一个过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。
```

### trim之后，数据在堆上的地址发生变化，v8是如何更新对应栈上的引用的
```
作者回复: JavaScript中的原始字符串是不可变的（immutable），也就是说，一旦一个字符串创建了，它在内存中的值就不可能改变，这和其他语言是有区别的。

所以当你调用trim方法后，v8引擎返回给你的是一个新字符串，并不是之前的字符串了。
```


### 副回收器的触发频率会高于主回收器吗？还是两者是同步触发的？
```
副垃圾回收器执行速度快，而且容易满，所以回收频率会比主垃圾回收器高。
```


### Perfomance模块的使用
```
做了这么长时间的前端开发，第一次关注内存泄漏的问题，以后得多关注这方面了。通过chrome的Perfomance面板记录页面的活动，然后在页面上进行各种交互操作，过一段时间后（时间越长越好），停止记录，生成统计数据，然后看timeline下部的内存变化趋势图，如果是有规律的周期平稳变化，则不存在内存泄漏，如果整体趋势上涨则说明存在内存泄漏。另外，想问下老师，这个内存变化趋势只是js堆内存的变化吗？因为我发现在统计图表下部分了几类：JS Heap、Documents、Nodes、Listeners、GPU Memory，JS Heap是占用最多的，其次是Nodes，再次是Listeners。
```

### 标记的过程具体是什么样的呢？
```
作者回复: 比如全局window对象看成是一个树状结构，垃圾回收时，V8会先遍历这颗树，能遍历到的元素说明还存活的，标记为活动对象！没有被标记到的说明已经没有被引用了。

同时V8还维护了一个空闲列表，也就是没有被使用的空闲空间列表，垃圾清理过程就是把没有标记的添加到空闲列表中！

这样就完成了“标记-清除”操作
```


### 1. JS 执行代码时是在执行声明语句时就分配内存还是赋值时分配？若是执行声明语句时就分配，那如何知道是大对象(存储在老生代)还是新对象(存储在新生代)？
```
作者回复: 声明变量是在编译阶段完成的，这时赋值语句还没执行！

比如 var a = 6

首先编译阶段确定有变量a了，并给a赋值undefined；

接下来执行代码，在执行过程中，会将6赋给a，这时候a等于6！

由于6是原生类型，通常情况下，会在栈上分配该变量！

如果 var a = Object

将对象赋给a时，在编译阶段 a依然等于undefined。
在执行过程中，会在堆中创建一块内存，存放Object的值，然后栈中有个指向堆中Object地址的指针
```



### 关于内存泄漏
```
没有被引用的闭包会被自动回收，不过如果没用的闭包还保存在全局变量中，依然会内存泄漏！
```

### 标记清除和标记整理是两个同等级的算法策略吗？目前v8使用的是两者结合，还是只有一种？
```
作者回复: 标记清除和标记整理可以看成是垃圾回收的两个阶段吧，v8在实现垃圾回收过程中，两种算法都用上了。
```


### 增量标记会受到中间穿插的js应用逻辑影响么？会造成标记结果不全或者错误么？
```
作者回复: 不全没关系，新产生的垃圾下次再回收，分配内存使用空闲列表里面的。
```


### 总结1
```
栈和堆

栈垃圾回收
当函数执行结束，JS引擎通过向下移动ESP指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。

堆垃圾回收
一、代际假说
1、大部分对象存活时间很短
2、不被销毁的对象，会活的更久

二、分类
V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

三、新生代
算法：Scavenge 算法
原理：
1、把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
3、先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中
4、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。
对象晋升策略：
经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

四、老生代
算法：标记 - 清除（Mark-Sweep）算法
原理：
1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
2、清除：将垃圾数据进行清除。
碎片：
对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

算法：标记 - 整理（Mark-Compact）算法
原理：
1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。
2、整理：让所有存活的对象都向内存的一端移动
3、清除：清理掉端边界以外的内存

优化算法：增量标记（Incremental Marking）算法
原理：
1、为了降低老生代的垃圾回收而造成的卡顿
2、V8把一个完整的垃圾回收任务拆分为很多小的任务
1、让垃圾回收标记和 JavaScript 应用逻辑交替进行
```


### 闭包形成的对象刚开始是属于新生代还是老生代？
```
作者回复: 看对象大小，小对象一开始会丢到新生代中去，当GC执行多次后，会被移动到老生代中。
```