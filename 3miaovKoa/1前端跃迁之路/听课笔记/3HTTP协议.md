### HTTP协议
HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础。通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等


### 浏览器端发起 HTTP 请求流程的步骤
- 1. 构建请求。首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。
```
GET /index.html HTTP1.1
```

- 2. 查找缓存
浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：
（1）缓解服务器端压力，提升性能（获取资源的耗时更短了）；
（2）对于网站来说，缓存是实现快速资源加载的重要组成部分。

- 3. 准备 IP 地址和端口
将域名映射为 IP 的系统就叫做“域名系统”，简称 DNS。
在地址栏输入url，浏览器的第一步是：会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。拿到IP之后就需要获取端口号了。

- 4. 等待 TCP 队列
现在准备好了端口和 IP 地址。但是Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

- 5. 建立 TCP 连接
排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接

- 6. 发送 HTTP 请求
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。

发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。
发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。


### 服务器端处理 HTTP 请求流程
- 1. 返回请求
首先服务器会返回响应行，包括协议版本和状态码。
然后发送响应体的数据，一般是html实际内容

- 2. 断开连接
通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了`Connection:Keep-Alive `。那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。

比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

- 3. 重定向



# 问题解答
### 1. 为什么很多站点第二次打开速度会很快？
第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。哪些数据会被缓存呢？通常是DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。其中DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来。

- 浏览器缓存数据是如何实现的？
当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的。比如：`Cache-Control:Max-age=2000`。在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上`If-None-Match:"4f80f-13c-3a1xb12a"`，根据 If-None-Match 的值来判断请求的资源是否有更新。
（1）如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”
（2）如果资源有更新，服务器就直接返回最新资源给浏览器。


### 2. 登录状态是如何保持的？
- 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。

- 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里（如：Set-Cookie: UID=3431uad），如下所示，然后把响应头发送给浏览器

- 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。

- 当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如Cookie: UID=3431uad），然后浏览器再将请求头发送给服务器。

- 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。

- 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。

简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。


### 总结
浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。




### 思考题：结合今天所讲 HTTP 请求的各个阶段，如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？

##### 回复1：
1、首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过ping curl看看对应的时延高不高。
2、然后通过wireshake看看具体哪里出了问题。
3、假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。
平常碰到很多http问题，基本都能通过上面方式搞定


##### 在浏览器中访问的时候打开network面板，发现缓存的来源有的from disk有的是from memory。对于资源什么情况下缓存到硬盘什么时候缓存到内存
这是浏览器的三级缓存机制，使用memory cache比disk cache 的访问速度要快，但是具体什么规则等我回头看下源码再来回答你了。还有另外一种cache，是service worker的cache。


##### 回复2：
使用 chrome network 面板，看那个 瀑布图 中每个阶段的含义，就可以判断问题出现在那个方向了，每个阶段的含义，https://developers.google.com/web/tools/chrome-devtools/network/reference#timing-explanation 举个例子 Content Download 如果太长，很有可能是下载的资源太大，但也有可能是网络慢导致的下载太慢，简单计算一下，在例如 Waiting (TTFB) 这个太长的话，有可能是网络慢，或者就是 后端处理时间过长导致的，至少可以排查掉前端原因，还有很多，例如 DNS lookup 等，但是最终要确认具体哪里慢，最好是结合系统日志去分析

##### 回复3：
1. 【等待TCP队列】页面需要加载资源数太多且比较大。因为浏览器的 TCP 连接数有限制，所以有些请求被阻塞了。解决方案有合并资源（比如将多个小的js文件合并为一个大的js文件，雪碧图等）、使用 HTTP2 甚至 HTTP3（解决连接数限制问题）
2. 【服务器处理请求】服务器负载过高，不能及时响应请求。
3. 【传输数据阶段】请求的地理位置过远甚至跨网络服务商。解决方案有使用 CDN。

一般查看network中Timing各个阶段的时间进行分析



### 拓展
- ctrl+F5和F5的区别：一个是强制刷新，一个是走正常流程

- 同域名只能建立6个tcp链接的话，那加载大量图片或者其他资源的时候不是很卡呢？
是的，通常如图片这种静态资源都是直接配置到cdn上的

- dns缓存是保存浏览器本地的，下次启动依然有结果；图片和其他域名都一样的，都会缓存在本地。


##### Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。 是指同一个域名下的6个并发请求么。我理解建立一个tcp连接，可以处理多个请求吧？
 http/1.1 一个tcp同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！

但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求！

不过http2是可以并行请求资源的，所以如果使用http2，浏览器只会为每个域名维护一个tcp连接

##### 老师，同一个域名同时最多只能建立 6 个 TCP 连接 是不是意思是统一域名同时只能发送6个AJAX请求吗， TCP连接和AJAX请求有什么关系吗
同一个域名同时最多只能建立 6 个 TCP 连接“ 指的不光是指Ajax，还包括页面中的资源加载，只要是一个域名下的资源，浏览器同一时刻最多只支持6个并行请求。

不过这是HTTP/1.1的规则，HTTP/2已经不用这套规则了，而且HTTP/2也很成熟了，有条件可以考虑切换到HTTP/2.

Ajax其实就是HTTP请求，包括了XMLHttpRequest和Fetch，HTTP请求是建立在TCP协议之上的。



##### https为什么能防止网络劫持？
ttp在传输过程中是明文的，所以数据在传输过程中是能够被截获或者修改的，比如谁在你电脑上安装了一个网络拦截软件，或者你的路由器被谁安装了监听软件，甚至在网络服务提供商都有可能修改你页面的内容，基于这些原因，我们需要在传输过程中加密数据，这就是https出现的原因，即便你拦截到了请求，获取的只是加密后的数据，拿到也没有什么用。


##### http的keep alive和http2中的信道服用有什么区别呢
一个http中的keep-alive是排队请求，也就是一个http请求完成之后才能继续请求下一个，而http2中请求是并发的，可以同时处理很多请求！


##### 你说chrome一次最多只能建立6个tcp连接，有点不理解，这是说只能支持6个用户并发吗？
是同一个域名下面，同一时间只能有6个并发请求，超过六个以上的需要排队！


##### http:127.0.0.1:8080 这个端口号既是Tomcat 应用端口号 也是 tcp连接用的 端口号吗
对 一回事



