### DOM 的缺陷
- 结论：
通过 JavaScript 操纵 DOM 是会影响到整个渲染流水线的。
- 例子：
调用document.body.appendChild(node)往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。

频繁的操作DOM会触发重绘和重排，触发渲染流水线。


### 虚拟 DOM做了哪些事
- 页面改变的内容应用到虚拟 DOM 上
- 当数据变化时候，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。
- 虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。

看下图：
![](https://static001.geekbang.org/resource/image/cf/90/cf2089ad62af94881757c2f2de277890.png)

结合React流程分析虚拟DOM是如何运行的：
- 创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。
- 更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。


关于React Fiber 更新机制：
- 当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。

关于上述的比较过程：
最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。

协程的另外一个称呼就是 Fiber，所以在这里我们可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler 相信你也很清楚了，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。


### 从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM

1、双缓存
在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。

使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。

你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。

核心结论：虚拟DOM看成DOM的一个buffer，在完成一次完整的操作之后，才会把结果用到DOM 上，只会刷新一次。


2.MVC 模式
从上面我们可以知道虚拟 DOM 是一种类似双缓存的实现。接下来我们再来看看虚拟 DOM 在 MVC 模式中所扮演的角色。

下面是MVC的图解：
![](https://static001.geekbang.org/resource/image/4c/a6/4c03b5882878dcce2df01c1e2e8db8a6.png)
MVC结构比较简单，由模型、视图和控制器组成，其核心思想就是将数据和视图分离，不让他们直接通信，而是通过控制器来完成。

结合redux来构建一个MVC 的模型结构，如下图：
![](https://static001.geekbang.org/resource/image/e0/03/e024ba6c212a1d6bfa01b327e987e103.png)

在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。实现过程如下：
（1）图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；
（2）模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；
（3）视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；
（4）新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；
（5）比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；
（6）DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。


