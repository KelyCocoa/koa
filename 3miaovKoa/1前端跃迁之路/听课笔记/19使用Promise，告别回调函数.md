Promise 到底解决了什么问题呢？ 解决的是异步编码风格的问题

而一段代码中太多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。当回调中存在多层嵌套时，就陷入了回调地狱，代码可读性非常差。

回调地狱存在的问题
- 第一是嵌套调用，下面的任务依赖于上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。
- 第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。


Promise实现了哪些功能？
- 实现了回调函数的延时绑定。将异步函数返回值在x1.then的回调函数中获取。

- 将回调函数onResolve的返回值穿透到最外层。根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了

之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。


### Promise 与微任务
执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。





# 思考
```
1、Promise 中为什么要引入微任务？
2、Promise 中是如何实现回调函数返回值穿透的？
3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？
```


### 疑问1：
异步AJAX请求是宏任务吧？Promise是微任务，那么用Promise进行的异步Ajax调用时宏任务还是微任务？
```
作者回复: ajax就是xmlhttprequest，必然是宏任务！

准确地说，Promise在执行resolve或者reject时，触发微任务，所以在Promise的executor函数中调用xmlhttprequest会触发宏任务。

如果xmlhttprequest请求成功了，通过resolve触发微任务

如果xmlhttprequest请求失败了，通过reject触发微任务
```

### 回复1
```
1、Promise 中为什么要引入微任务？

由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务

2、Promise 中是如何实现回调函数返回值穿透的？
首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），将前一个promise的data值赋给新建的promise

3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获
promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误
```

### 疑问2
老师 渲染流水线 在 微任务 之前 还是 之后 执行啊？
```
作者回复: 微任务也可以不触发渲染操作，也可以出发渲染操作！

比如你也可以在微任务中通过js来修改dom，触发重绘，重排等动作！

你也可以在微任务中执行一些逻辑运算，这就和页面渲染没有关系了！
```




### 一些拓展方法
- promise.race的使用场景：可以用于快捷地测试接口反应速度。
- 关于手写Promise娓娓道来（参照逼站）

