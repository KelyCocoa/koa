每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。

消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

本文讲解浏览器页面主线程是如何运作的。

### 使用单线程处理安排好的任务
```
void MainThread(){
    int num1 = 1+2; //任务1
    int num2 = 20/5; //任务2
    int num3 = 7*8; //任务3
    print("最终计算的值为:%d,%d,%d",num1,num2,num3)； //任务4
}
```
（1）把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。（所有的过程都是按照顺序执行的）,下面是第一版本的执行过程：
![](https://static001.geekbang.org/resource/image/72/bc/72726678ac6604116c1d5dad160780bc.png)

但是很多情况下，新的任务都是在线程运行过程中产生的。这个时候就不能像上面那样先把所有任务先丢进去然后执行。

（2）要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。我们可以通过一个 for 循环语句来监听是否有新的任务。相比较1中的情况，这一版本的线程做了两点改进。
```
//GetInput
//等待用户从键盘输入一个数字，并返回该输入的数字
int GetInput(){
    int input_number = 0;
    cout<<"请输入一个数:";
    cin>>input_number;
    return input_number;
}

//主线程(Main Thread)
void MainThread(){
     for(;;){
          int first_num = GetInput()；
          int second_num = GetInput()；
          result_num = first_num + second_num;
          print("最终计算的值为:%d",result_num)；
      }
}
```
- 第一点引入了循环机制，具体实现方式是在线程语句最后添加了一个 for 循环语句，线程会一直循环执行。
- 第二点是引入了事件（这里的事件不是太理解），可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。

这是第二版本的执行过程：
！[](![](https://static001.geekbang.org/resource/image/72/bc/72726678ac6604116c1d5dad160780bc.png))

上面版本引入了事件循环机制，但是所有的任务都是来自于线程的内部。如果另一个线程想让主线程执行一个任务，则还需要在这个版本上改进。


### 处理其他线程发送过来的任务
下面是渲染进程和其他进程之间的信息传输关系：
！[](https://static001.geekbang.org/resource/image/2e/05/2eb6a8ecb7cb528da4663573d74eb305.png)

渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了。接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。

那么如何设计好一个线程模型，能让其能够更好的接收其他线程发送的消息呢？
一个通用模式是使用消息队列。

![](https://static001.geekbang.org/resource/image/6d/5e/6d141ec0925590d83d97a37cce8e6f5e.png)
消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

（3）下面是改造后的第三版线程模型（队列 + 循环）
![](https://static001.geekbang.org/resource/image/2a/ab/2ac6bc0361cb4690c5cc83d8abad22ab.png)
存在下列三个步骤：
1、添加一个消息队列；
2、IO 线程中产生的新任务添加进消息队列尾部；
3、渲染主线程会循环地从消息队列头部中读取任务，执行任务。

整个逻辑代码是这样的（考虑到其他线程的任务）：
添加了一个消息队列的对象，然后在主线程for循环代码块中遍历消息队列，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。
这样改造后，主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了。

<strong>由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁，这块内容你也要注意下。</strong>


### 处理其他进程发送过来的任务
上面讲的是同一个进程中多个线程之间的任务处理情况。但是真实情况下跨进程之间的任务也是频繁发生的。
![](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)
从图中可以看出，渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程



### 消息队列中的任务类型
任务类型中包括
- 内部消息类型，如：输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器
- 与页面相关的事件：如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。
这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。


### 如何安全退出
确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程。


### 页面使用单线程的缺点
页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决：

- 第一个问题是如何处理高优先级的任务。
这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率（添加到队列头部）；如果采用异步方式，又会影响到监控的实时性（排到队列尾部）。

针对这种情况引入了微任务
通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列（这就解决了执行效率的问题），在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务（这就解决了实时性的问题）。

- 第二个是如何解决单个任务执行时长过久的问题。
因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。如下图：

![](https://static001.geekbang.org/resource/image/8d/cc/8de4b43fca99b180fdffe6a5af07b5cc.png)

如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。



### 关键词
- 浏览器页面主线程（渲染进程的主线程）是如何运作
    - 消息队列（添加一个队列来接收IO进程传过来的任务）
    - 事件循环（在主线程上对消息队列进行遍历，提取队列中的任务并执行）

- 处理其他线程发送过来的任务
    - 渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息。然后其他线程发送过来的任务会通过IO线程传给消息队列，然后再通过事件循环执行

- 页面使用单线程的缺点
    - 如何处理高优先级的任务：引入了微任务；在消息队列中的任务是宏任务，每个宏任务都有一个微任务列表。
        - 如果采用同步方式（插入队列的头部），会影响当前任务的执行效率。
        - 如果采用异步方式（滞后插入到队列的尾部），又会影响到监控的实时性。
    - 如何解决单个任务执行时长过久的问题：引入了回调，让当前的js任务滞后执行。


# 思考
消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？

### 疑问1
老师，我感觉最近学起来很迷茫。我本身是非计算机专业的，转行前端将近一年，也能照搬代码去干活，但是总感觉很多东西不通，整个就是一个闭塞的状态，于是我把今年的目标定为恶补计算机基础知识，然后我就找计算机网络方面的知识，浏览器方面的，也包括您的这个专栏，并且也结合着极客时间另外一个关于http的专栏，感觉看的时候好像是懂了（其实我也知道也只是停留在我这个知识层面的“懂了”），会有那种原来平时工作时候他们说的那些概念是这样的意思，也会觉得曾经觉得很难得东西，一下子就通了的感觉，但是另一边我又发现一个问题就是看到现在，像之前专栏讲的我就忘了，平时打通的点也都没有太多印象。我有点迷茫了，我不知道是不是因为我实操太少了，平时遇到的问题太少，所以在学这些的时候会印象不深刻。难道我现在应该把更多的精力放在框架的使用，不停的写代码，而不是基础上吗？
```
作者回复: 首先我的观点是工作和知识体系的构建都是重要的，这两者向铺相成。
所以学习过程也是停不下来的，基础知识的学习不要间断。
工作是实践的好机会，但是在工作中你涉及到内容通常会限定在一个很窄的领域，要想通过工作拓宽自己的知识边界，那该如何突破呢？
我是这样做：
把工作中的项目看成是一个探险游戏，游戏中有你熟悉的领域，也有你不熟悉的领域，通常你所做的工作都是在你最熟悉的领域。
不过我还会做另外一件事，就是把游戏地图画出来，画地图的过程也就是全面熟悉项目架构的过程，其中可能涉及到很多你不熟悉的领域，然后你要做的事逐步拓宽这张地图！
当然人的精力是有限的，所以搭建知识架构很重要，然后再找几个领域深耕。
```


### 回复1
宏任务是开会分配的工作内容，微任务是工作过程中被临时安排的内容，可以这么比喻吗？
```
 这个比喻形象
```

### 总结1
为了应对渲染进程主线程繁琐的任务（DOM解析、样式计算、布局、处理js任务、各种输入事件），引入了消息队列和事件循环系统。
从任务的复杂度逐渐增加，循序渐进的分析每种场景的处理方式。
1. 单线程处理安排好的同步任务
2. 引入事件循环接受新的任务
3. 引入消息队列处理其他进程发来的任务
4. 引入宏任务和微任务解决任务优先级的问题
5. 通过Js回调功能解决单个js任务执行时间过长的问题。
```
微任务的理解应该是：

每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到该列表中，等宏任务快执行结束之后，会执行微任务列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别！我们后面再介绍，你可以重点关注下。
```


### 问题2
老师请教个问题 用CSS3实现动画是不是不会影响主线程，和用JS实现动画会影响主线程，这个说法对么？
```
作者回复: 是这样的，部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。

JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！
```

### 问题3
老师，为什么说页面是单线程架构？

默认情况下每个标签页都会配套一个渲染进程，而一个渲染进程里不是有主线程、合成线程、IO线程等多个线程吗

是因为【排版引擎 blink】 和【JavaScript引擎 v8】都工作在渲染进程的主线程上并且是互斥的，基于这点说页面是单线程架构？
```
是的，他们都是在渲染进程的主线程上工作，所以同时只能执行一个。

比如v8除了在主线程上执行JavaScript代码之外，还会在主线程上执行垃圾回收，所以执行垃圾回收时停止主线程上的所有任务，我们把垃圾回收这个特性叫着全停顿。
```


### 问题4
由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁。
请问老师，JS执行不是单线程的吗？为什么这里会说是由多个线程操作同一个队列？
```
作者回复: 这里提到的任务是指浏览器所以需要处理的任务！
浏览器是基于多进程+多线程架构的，所以多进程通讯（IPC）和多线程同步的问题！
因为JavaScript引擎是运行在渲染进程的主线程上的，所以我们说JavaScript是单线程执行的！
```


### 问题5
老师，可以请问下：渲染进程的主线程和V8执行机主线程是同一个线程吗？一个渲染进程有几个线程，分别有啥作用？
```
作者回复: 主要有IO线程，用开负责和其它进程IPC通信的，然后主线程主要跑页面的！

V8是在主线程上执行的，因为dom操作啥的都是在主线程上执行的。

当然还有其它很多辅助线程，比如预解析DOM的线程，垃圾回收也有一些辅助线程。
```



### 问题6
在渲染进程里面，除了I/O线程，其他线程也会往消息队列中添加任务，是吗？
```
作者回复: 有啊，比如渲染过程就有合成线程，解析DOM过程中还有预解析线程，这些现场都会和主线程有交互的
```

- 就一个线程也是可以使用消息队列的，任务过多，需要排队执行，就需要引入队列


### 何为高优先级的任务？如果当前正在执行一个任务，突然有个高优先级的任务，那么当前这个任务要暂停，先执行这个高优先级的任务吗？这个高优先级的任务执行完后，在接着执行当前的任务？
```
作者回复: 任务是原子性的，执行了就不会中断
```


### 老师，微任务队列是不是只可能存在与任务队列中当前正在执行的任务中？就是说在当前任务中创建微任务队列？
```
作者回复: 对的，当前任务创建的微任务一定会在当前任务结束之前执行掉！

```

### 接收到消息之后，会将这些消息组装成任务发送给渲染主线程,这里的【渲染主线程】应该是【消息队列】吧？
```
作者回复: 嗯，你的理解的是对的
```