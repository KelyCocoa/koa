```
异步编程解决方案（按照时间线）

1、方案1：Promise

Promise.all
    使用方式：所有异步都成功了则成功，否则返回失败的那个数据。异步执行顺序按照给定数组的顺序执行。
    应用场景：多个异步同时执行或者有先后顺序，最后需要统一使用这几个异步返回值的时候。异步获取结果的顺序会严格按照传入数组的顺序，与等待时间无关

    接收一个Promise对象的数组集合，当数组中所有的Promise对象都成功执行了，则成功，值是所有成功函数返回值组成的数组；否则当其中有一个执行失败了，获取的值是失败的那个参数;

Promise.race
    使用方式：只返回第一个执行完毕的promise的结果，无论结果是fullfilled还是rejected。
    应用场景：用于快捷地测试接口反应速度。

    接收一个Promise对象的数组集合，其中哪个Promise最先执行完成，则获取该返回的值（无论是这个结果是成功的还是失败的）




2、方案2：Generator
    在形式上，Generator是一个普通函数，但是有两个特征。
        一是，function命令与函数名之间有一个星号
        二是，函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态。

    迭代：
       generator返回一个迭代函数，调用next方法才能执行generator函数中的每一个yield

    注意：
        在next函数返回值{value:"", done: false}中的value值来自于该异步函数的返回值，done表示迭代是否完成（即是否还有yield异步方法）


3、方案3：async/await方法
    使用方式上和迭代器类似
```

